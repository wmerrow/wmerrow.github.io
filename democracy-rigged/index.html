<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="utf-8">
      <title>Slider</title>
      <script type="text/javascript" src= "https://d3js.org/d3.v6.js"></script>
      <script type="text/javascript" src= "d3-simple-slider.js"></script>
      <link rel="stylesheet" href="styles.css">
  </head>
  <body>

    <section>

      <h1>American Democracy Is Rigged Against Democrats</h1>
      
      <div id="introBlurb">
        <div class="byline">
          <p class="bylineP">By Will Merrow</p>
          <p class="bylineP">INFO 697: Programming Interactive Data Vis</p>
          <p class="bylineP">Fall 2020</p>
        </div>
        <p>Republicans lost the popular vote but won the presidency in 2000 and 2016, and almost did it again in 2020. How is this possible? The answer is that Republicans have a <strong>built-in advantage</strong> in the rules of the electoral college. </p>
        <p>In fact, Republicans also have a built-in advantage in the House and the Senate, which are even harder for Democrats to win. This means that Republicans can lose the popular vote but still win the presidency, House, and Senate, while Democrats need a landslide popular vote victory to win all three.</p>
        <p>The graphics below show the outcome under different popular vote scenarios, imagining that states and districts vote according to whether they lean Democrat or Republican after including the popular vote scenario. For example, in a "D +3" scenario, Democrats would win a state like Pennsylvania even though it leans more Republican than the average.</p>
        <p>Use the slider to see how different scenarios lead to different outcomes, and read on to understand why Republicans have such a strong built-in advantage.</p>
      </div> 

      <div class="row">  
        <h4>Choose a scenario</h4>
        <svg id="introSlider" class="vis sliderSvg"></svg>
      </div>

      <div class="row">
        <p class="majorityLabel">Majority</p>
        <div class="leftLabel">
          <h3>Popular vote</h3>
        </div>
        <svg id="introPop" class="introVis barStandard"></svg>
        <div class="rightLabel">
          <svg id="introPopResult" class="introVis"></svg>
        </div>
      </div>

      <div class="row">
        <div class="leftLabel">
          <h3>Presidency</h3>
        </div>
        <svg id="introPresChart" class="introVis barStandard"></svg>
        <div class="rightLabel">
          <svg id="introPresResult" class="introVis"></svg>
        </div>
      </div>

      <div class="row">
        <div class="leftLabel">
          <h3>House</h3>
        </div>
        <svg id="introHouseChart" class="introVis barHouse"></svg>
        <div class="rightLabel">
          <svg id="introHouseResult" class="introVis"></svg>
        </div>
      </div>

      <div class="row">
        <div class="leftLabel">
          <h3>Senate</h3>
        </div>
        <svg id="introSenateChart" class="introVis barStandard"></svg>
        <div class="rightLabel">
          <svg id="introSenateResult" class="introVis"></svg>
        </div>
      </div>

    </section>

    <section>
      <h2>The Presidency</h2>
      <div class="explainer">
        <p>The Presidency is biased in favor of Republicans because of the electoral college, where states are <strong>winner-take-all</strong>. In each state, the losing party's votes are "wasted" - whether they lost in a landslide or a slim margin. Currently, there are more wasted Democratic votes than Republican votes. For example, in states like Florida and Texas, Democrats usually do well but not well enough to win.</p>
        <p>An additional reason for pro-Republican bias is that each state gets a number of electoral votes equal to the number of congressional districts <strong>plus two</strong>, favoring small states.</p>
        <p>The electoral college hasn't always favored Republicans, and could shift to favor Democrats in the future if demographic changes result in more wasted Republican votes in states like Florida and Texas.</p>
        <p>One solution to this problem is state-level initiatives like Maine and Nebraska have adopted - in these states, instead of a winner-take-all system, the winner of each congressional district gets one electoral vote, and the statewide winner gets two votes.</p>
      </div>
      <div class="panel" id="pres">
        <svg id="presSlider" class="vis sliderSvg"></svg>
        <div class="arrowContainer">
          <svg id="presPopResult"></svg>
          <p class="arrow">&#8594;</p>
          <svg id="presPresResult"></svg>
        </div>
        <svg id="presMap" class="vis"></svg>
        <svg id="presChart" class="vis barStandard"></svg>
        <!-- <svg id="presPop" class="vis barStandard"></svg> -->
      </div>
    </section>

    <section>
      <h2>The House of Representatives</h2>
      <div class="explainer">
        <p>Republicans have an even larger advantage in the House - Democrats need to win the popular vote by five points just to win a majority. This is because each district is winner-take-all, and as with the presidency, there are more "wasted" Democratic votes than Republican votes.</p>
        <p>One reason for this is <strong>gerrymandering</strong>, where a party draws the district boundaries to favor itself. By packing the other party's voters into one district, a party can lose that district but win more districts overall. The other reason for this is the natural pattern of <strong>where Democrats and Republicans live</strong> - urban areas tend to be heavily Democratic.</p>
        <p>The solution to this would be for Democrats to win state legislatures and redraw the district boundaries, but this only happens every decade, and Democrats failed to win the needed state houses in 2020.</p>
      </div>
      <div class="panel" id="house">
        <svg id="houseSlider" class="vis sliderSvg"></svg>
        <div class="arrowContainer">
          <svg id="housePopResult"></svg>
          <p class="arrow">&#8594;</p>
          <svg id="houseHouseResult"></svg>
        </div>
        <svg id="houseMap" class="vis"></svg>
        <svg id="houseChart" class="vis barHouse"></svg>
        <!-- <svg id="housePop" class="vis barStandard"></svg> -->
      </div>
    </section>
    
    <section>
      <h2>The Senate</h2>
      <div class="explainer">
        <p>Last but definitely not least, the Senate has an extreme structural bias towards Republicans, far more than the presidency or the House. In the Senate, <strong>each state has two senators regardless of population</strong>. This means a small population state like Wyoming has the same power as a large state like California. There are more Republican-leaning states than Democratic-leaning states, so the Republicans have an advantage.</p>
        <p>The advantage is enormous - Republicans can lose the popular vote by six points and still maintain control of the Senate. Having a filibuster-proof majority of 60 senators, as the Democrats did in 2008 when they passed Obamacare, is inconceivable in the near term.</p>
        <p>The only possible way for Democrats to even the playing field in the Senate is to create multiple new states that lean Democratic, for example, giving statehood to D.C. and Puerto Rico. But this would require - wait for it - control of the Senate.</p>
      </div>
      <div class="panel" id="senate">
        <svg id="senateSlider" class="vis sliderSvg"></svg>
        <div class="arrowContainer">
          <svg id="senatePopResult"></svg>
          <p class="arrow">&#8594;</p>
          <svg id="senateSenateResult"></svg>
        </div>
        <svg id="senateMap" class="vis"></svg>
        <svg id="senateChart" class="vis barStandard"></svg>
        <!-- <svg id="senatePop" class="vis barStandard"></svg> -->
      </div>
    </section>

    <section>
      <p>Data source: FiveThirtyEith partisan-lean dataset, which uses election results from recent elections. The dataset weighs more recent elections the most, but does not yet include data for the 2020 election.</p>
    </section>
        
    <script type="text/javascript">
    
    Promise.all([
      d3.csv("data/pres_data.csv"),
	    d3.csv("data/house_data.csv"),
	    d3.csv("data/senate_data.csv"),
      d3.csv("data/pop_data.csv")
	])
     .then(function(data) {

      const pres_data = data[0];
      const house_data = data[1];
      const senate_data = data[2];
      const pop_data = data[3];

      console.log(pres_data);
      console.log(house_data);
      console.log(senate_data);
      console.log(pop_data);


      // DIMENSIONS

      // margins

      const margin = {
        top: 10,
        right: 10,
        bottom: 10,
        left: 10
      };

      // squares

      const squareScale = 1.5

      const pres_square = {
        w: squareScale * 30,
        h: squareScale * 30
      };
      const house_square = {
        w: squareScale * 4,
        h: squareScale * 4
      };
      const senate_square = {
        w: squareScale * 7,
        h: squareScale * 7
      };

      // panel dimensions

      const panelWidth = 600;

      const map = {
        w: panelWidth, // width of map
        h: panelWidth * 0.61835245046 // map aspect ratio
      };

      const bar = {
        w: panelWidth, // width of map
        h: panelWidth / 87 * 5 // sets height all bar charts so that house squares will be perfectly square (house grid is 87 by 5)
      };

      const sliderSize = {
        w: panelWidth * 0.75,
        h: 50
      };

      const sliderMargin = 15;


      // SCALES

      const red = '#d6433e';
      const blue = '#1b67c4';
      const gray = '#666666';

      // color scale
      const leanColor = d3.scaleThreshold()
        .domain([0]) // split at 0
        .range([blue, red]);

      // pres state size scale
      const presSize = d3.scaleSqrt()
      	.domain([0, 55]) // max electoral votes is 55 (California)
      	.range([0, pres_square.w]);
      
      // slider min/max
      const voteMaxD = -8;
      const voteMaxR = 8;
      // slider increment
      const increment = 2;
      // create array of integers to use for slider ticks
      const voteRange = [];
      for (var i = voteMaxD; i <= voteMaxR; i = i + increment) {
        voteRange.push(i);
      }


      // SLIDER AND RESULTS

      // define function to add slider and results
      function addSlider(section) {

        // const sliderWidth = 0;
        // const sliderHeight = 0;

        // if (section == 'intro') {
        //   sliderWidth = sliderSize.w;
        //   sliderHeight = sliderSize.h;
        // } else {
        //   sliderWidth = panelSlider.w;
        //   sliderHeight = panelSlider.h;
        // };

        const sliderWidth = sliderSize.w;
        const sliderHeight = sliderSize.h;
        // for selecting appropriate svg
        const sliderSvg = '#' + section + 'Slider';

        // define the slider
        const slider = d3.sliderTop()
          .min(voteMaxD)
          .max(voteMaxR)
          .default(0)
          .step(.5)
          .width(sliderWidth - sliderMargin * 2)
          // custom slider symbol
          .handle(
            d3.symbol()
              .type(d3.symbolCircle)
              .size(150)()
            )
          .tickValues(voteRange)
          .tickPadding(-3)
          // remove minus signs
          // .tickFormat(Math.abs)
          .tickFormat((function (v) {
              if (v == 0) {
                return 'Even';
              } else if (v < 0) {
                return 'D +' + Math.abs(v); 
              } else if (v > 0) {
                return 'R +' + Math.abs(v); 
              };
          }))
          .displayValue(false)
          // onchange, pass slider value to update function
          .on('onchange', function (value) {
            update(section, value); // updates appropriate section
          });

        d3.select(sliderSvg)
          .attr('width', sliderWidth)
          .attr('height', sliderHeight)
          .append('g')
          .attr('transform', 'translate(' + sliderMargin + ',' + (sliderSize.h - 10) + ')')
          .call(slider);

        // add slider titles
        // d3.select('#introSlider')
        //   .append('text')
        //   .attr('class', 'sliderTitle')
        //   .text('Scenario')
        //   .attr('transform', 'translate(' + (sliderWidth) / 2 + ', 21)');

        // add result titles
        // d3.selectAll('.slider')
        //   .append('text')
        //   .attr('class', 'sliderTitle')
        //   .text('Popular Vote')
        //   .attr('transform', 'translate(' + (sliderSize.w - sliderMargin * 2) / 2 + ', -45)');

      };

      addSlider('intro');
      addSlider('pres');
      addSlider('house');
      addSlider('senate');


///// gradient test

// var colorRange = ['#d7191c', '#1a9641'] //['#ffffcc', '#a1dab4', '#41b6c4', '#2c7fb8', '#253494']

// var color = d3.scaleLinear().range(colorRange).domain([1, 2]);

// var mySvg = d3.select('body')
//     .append('svg')
//     .attr("width", 500)
//     .attr("height", 500)
//     .append("g")
//     .attr("transform", "translate(" + (10) + "," + (10) + ")");

// var linearGradient = mySvg.append("defs")
//     .append("linearGradient")
//     .attr("id", "linear-gradient");

// linearGradient.append("stop")
//     .attr("offset", "0%")
//     .attr("stop-color", color(1));

// linearGradient.append("stop")
//     .attr("offset", "100%")
//     .attr("stop-color", color(2));

// mySvg.append('line')
//     .attr('x1', 10)
//     .attr('x2', 100)
//     .attr('y1', 150)
//     .attr('y2', 150)
//     .attr("stroke-width", 6)
//     .attr("stroke", "url(#linear-gradient)");

// mySvg.append('path')
//     .attr('d', "M 10 10 H 90 V 90 H 10 Z")
//     .attr("stroke-width", 6)
//     .attr("stroke", "url(#linear-gradient)");

// mySvg.append('rect')
//     .attr('x', 110)
//     .attr('y', 0)
//     .attr('width', 50)
//     .attr('height', 50)
//     .attr("stroke-width", 6)
//     .attr("stroke", "url(#linear-gradient)");



// d3.select('#test')
//   .attr("stroke", "url(#linear-gradient)");
//   //.attr("stroke", "red");

// //// specify slider track color
// d3.selectAll('.track-inset')
//   .attr("stroke", "url(#linear-gradient)");
//   //.attr("stroke", "red");





      // SVG dimensions

      const result = {
        w: 200,
        h: 40
      };

      // intro chart SVGs
      const introPopSvg = d3.select('#introPop')
        .attr('width', bar.w + margin.left + margin.right)
        .attr('height', bar.h + margin.top + margin.bottom);
      const introPresBarSvg = d3.select('#introPresChart')
        .attr('width', bar.w + margin.left + margin.right)
        .attr('height', bar.h + margin.top + margin.bottom);
      const introHouseBarSvg = d3.select('#introHouseChart')
        .attr('width', bar.w + margin.left + margin.right)
        .attr('height', bar.h + margin.top + margin.bottom);
      const introSenateBarSvg = d3.select('#introSenateChart')
        .attr('width', bar.w + margin.left + margin.right)
        .attr('height', bar.h + margin.top + margin.bottom);

      const introPopResultSvg = d3.select('#introPopResult')
        .attr('width', result.w)
        .attr('height', result.h);
      const introPresResultSvg = d3.select('#introPresResult')
        .attr('width', result.w)
        .attr('height', result.h);
      const introHouseResultSvg = d3.select('#introHouseResult')
        .attr('width', result.w)
        .attr('height', result.h);
      const introSenateResultSvg = d3.select('#introSenateResult')
        .attr('width', result.w)
        .attr('height', result.h);

      const presPopResultSvg = d3.select('#presPopResult')
        .attr('width', 282)
        .attr('height', result.h);
      const presPresResultSvg = d3.select('#presPresResult')
        .attr('width', 282)
        .attr('height', result.h);

      const housePopResultSvg = d3.select('#housePopResult')
        .attr('width', 282)
        .attr('height', result.h);
      const houseHouseResultSvg = d3.select('#houseHouseResult')
        .attr('width', 282)
        .attr('height', result.h);

      const senatePopResultSvg = d3.select('#senatePopResult')
        .attr('width', 282)
        .attr('height', result.h);
      const senateSenateResultSvg = d3.select('#senateSenateResult')
        .attr('width', 282)
        .attr('height', result.h);

      // panel chart SVGs
      const presBarSvg = d3.select('#presChart')
        .attr('width', bar.w + margin.left + margin.right)
        .attr('height', bar.h + margin.top + margin.bottom);
      const houseBarSvg = d3.select('#houseChart')
        .attr('width', bar.w + margin.left + margin.right)
        .attr('height', bar.h + margin.top + margin.bottom);
      const senateBarSvg = d3.select('#senateChart')
        .attr('width', bar.w + margin.left + margin.right)
        .attr('height', bar.h + margin.top + margin.bottom);
      const presPopSvg = d3.select('#presPop')
        .attr('width', bar.w + margin.left + margin.right)
        .attr('height', bar.h + margin.top + margin.bottom);
      const housePopSvg = d3.select('#housePop')
        .attr('width', bar.w + margin.left + margin.right)
        .attr('height', bar.h + margin.top + margin.bottom);
      const senatePopSvg = d3.select('#senatePop')
        .attr('width', bar.w + margin.left + margin.right)
        .attr('height', bar.h + margin.top + margin.bottom);
      
      // panel map SVGs
      const presMapSvg = d3.select('#presMap')
        .attr('width', map.w + margin.left + margin.right)
        .attr('height', map.h + margin.top + margin.bottom);
      const houseMapSvg = d3.select('#houseMap')
        .attr('width', map.w + margin.left + margin.right)
        .attr('height', map.h + margin.top + margin.bottom);
      const senateMapSvg = d3.select('#senateMap')
        .attr('width', map.w + margin.left + margin.right)
        .attr('height', map.h + margin.top + margin.bottom);


      // add g for each state in appropriate position
      // const g = svg.append('g')
      //   .selectAll('g')
      //   .data(data)
      //   .enter()
      //   .append('g')
      //   .attr('transform', d=>{return 'translate(' + (d.col * square.w + margin.left) + ',' + (d.row * square.h + margin.top) + ')';});


      // MAPS

      // basemaps

      const basemap = function (svg) {
	      svg.append("svg:image")
		    .attr("xlink:href", "media/us_map.svg")
		    .attr("width", map.w)
		    .attr("x", margin.left)
		    .attr("y",margin.top);
  		};

  	  basemap(presMapSvg);
  	  basemap(houseMapSvg);
  	  basemap(senateMapSvg);

      // squares for maps

      presSquares = presMapSvg.selectAll('rect')
        .data(pres_data)
        .join('rect')
        // x and y position account for size of square in order to center square
        .attr('x', d=> (+d.state_x + +d.offset_x) * map.w + margin.left - presSize(+d.electors) / 2)
        .attr('y', d=> (+d.state_y + +d.offset_y) * map.h + margin.top - presSize(+d.electors) / 2)
        .attr('width', d=> presSize(+d.electors))
        .attr('height', d=> presSize(+d.electors))
        .attr('class', 'rect');

      houseSquares = houseMapSvg.selectAll('rect')
        .data(house_data)
        .join('rect')
        // position squares for each state, using state coordinates and then using modulo to create columns, with column size determined by the square root of the total districts in state, resulting in roughly square grids
        .attr('x', (d, i)=> {return (+d.state_x + +d.offset_x) * map.w + margin.left + Math.floor((d.district_number - 1) / Math.ceil(Math.sqrt(d.state_total))) * house_square.w - Math.ceil(Math.sqrt(d.state_total)) * house_square.w / 2;})
        .attr('y', (d, i)=> {return (+d.state_y + +d.offset_y) * map.h + margin.top + ((d.district_number - 1) % Math.ceil(Math.sqrt(d.state_total))) * house_square.h - Math.ceil(Math.sqrt(d.state_total)) * house_square.h / 2;})
        .attr('width', house_square.w)
        .attr('height', house_square.h)
		    .attr('class', 'rect');	

      senateSquares = senateMapSvg.selectAll('rect')
        .data(senate_data)
        .join('rect')
        .attr('x', d=> +d.state_x * map.w + +d.offset_x * senate_square.w + margin.left)
        .attr('y', d=> +d.state_y * map.h + +d.offset_y * senate_square.h + margin.top)
        .attr('width', senate_square.w)
        .attr('height', senate_square.h)
        .attr('class', 'rect');


      // BAR CHARTS

      // function for stacking data (for pres bar chart)
      const myStack = function (dataToStack) {
		  const total = d3.sum(dataToStack, d => d.electors);
		  let stackPosition = 0;
		  return dataToStack.sort((a,b)=>d3.ascending(+a.rlean, +b.rlean))
		  	.map(d => ({
			    state: d.state,
			    col: d.col,
			    row: d.row,
			    rlean: d.rlean,
			    electors: +d.electors,
			    startPosition: stackPosition,
			    endPosition: (stackPosition += +d.electors)
		  	}));
	  };

      // panel bar charts

      presBar = presBarSvg.selectAll('rect')
        .data(myStack(pres_data)) // uses stacked data
        .join('rect')
        .attr('x', d=> d.startPosition / 538 * bar.w + margin.left)
        .attr('y', margin.top)
        .attr('width', d=> d.electors / 538 * bar.w)
        .attr('height', bar.h)
        //.attr('vector-effect', 'non-scaling-stroke')
        .attr('class', 'rect');

      houseBar = houseBarSvg.selectAll('rect')
        .data(house_data.sort((a,b)=>d3.ascending(+a.rlean, +b.rlean)))
        .join('rect')
        // determine x and y, wrapping from one column to the next (wrap to next column after 5 squares)
        .attr('x', (d, i)=>{return Math.floor(i / 5) * bar.w / 87 + margin.left;}) // use math.floor to determine column
        .attr('y', (d, i)=>{return (i % 5) * bar.h / 5 + margin.top;}) // use modulo to determine row
        .attr('width', bar.w / 87)
        .attr('height', bar.h / 5)
        .attr('class', 'rect');

      senateBar = senateBarSvg.selectAll('rect')
        .data(senate_data.sort((a,b)=>d3.ascending(+a.rlean, +b.rlean)))
        .join('rect')
        .attr('x', (d, i)=> i * bar.w / 100 + margin.left)
        .attr('y', margin.top)
        .attr('width', bar.w / 100)
        .attr('height', bar.h)
        .attr('class', 'rect');

      presPop = presPopSvg.selectAll('rect')
        .data(pop_data.sort((a,b)=>d3.ascending(+a.rlean, +b.rlean)))
        .join('rect')
        .attr('x', (d, i)=> i * bar.w / 400 + margin.left)
        .attr('y', margin.top)
        .attr('width', bar.w / 400)
        .attr('height', bar.h);

      housePop = housePopSvg.selectAll('rect')
        .data(pop_data.sort((a,b)=>d3.ascending(+a.rlean, +b.rlean)))
        .join('rect')
        .attr('x', (d, i)=> i * bar.w / 400 + margin.left)
        .attr('y', margin.top)
        .attr('width', bar.w / 400)
        .attr('height', bar.h);

      senatePop = senatePopSvg.selectAll('rect')
        .data(pop_data.sort((a,b)=>d3.ascending(+a.rlean, +b.rlean)))
        .join('rect')
        .attr('x', (d, i)=> i * bar.w / 400 + margin.left)
        .attr('y', margin.top)
        .attr('width', bar.w / 400)
        .attr('height', bar.h);

      // intro bar charts

      introPopBar = introPopSvg.selectAll('rect')
        .data(pop_data.sort((a,b)=>d3.ascending(+a.rlean, +b.rlean)))
        .join('rect')
        .attr('x', (d, i)=> i * bar.w / 400 + margin.left)
        .attr('y', margin.top)
        .attr('width', bar.w / 400)
        .attr('height', bar.h);

      introPresBar = introPresBarSvg.selectAll('rect')
        .data(myStack(pres_data)) // uses stacked data
        .join('rect')
        .attr('x', d=> d.startPosition / 538 * bar.w + margin.left)
        .attr('y', margin.top)
        .attr('width', d=> d.electors / 538 * bar.w)
        .attr('height', bar.h)
        //.attr('vector-effect', 'non-scaling-stroke')
        .attr('class', 'rect');

      introHouseBar = introHouseBarSvg.selectAll('rect')
        .data(house_data.sort((a,b)=>d3.ascending(+a.rlean, +b.rlean)))
        .join('rect')
        // determine x and y, wrapping from one column to the next (wrap to next column after 5 squares)
        .attr('x', (d, i)=>{return Math.floor(i / 5) * bar.w / 87 + margin.left;}) // use math.floor to determine column
        .attr('y', (d, i)=>{return (i % 5) * bar.h / 5 + margin.top;}) // use modulo to determine row
        .attr('width', bar.w / 87)
        .attr('height', bar.h / 5)
        .attr('class', 'rect');

      introSenateBar = introSenateBarSvg.selectAll('rect')
        .data(senate_data.sort((a,b)=>d3.ascending(+a.rlean, +b.rlean)))
        .join('rect')
        .attr('x', (d, i)=> i * bar.w / 100 + margin.left)
        .attr('y', margin.top)
        .attr('width', bar.w / 100)
        .attr('height', bar.h)
        .attr('class', 'rect');   

      // reference lines

      const house_grid_square = bar.w / 87;

      d3.selectAll('.barStandard')
        .append('path')
        .attr('d', 'M ' + (margin.left + bar.w / 2) + ' 5' + ' V ' + (bar.h + margin.top * 2 - 5))
        .attr("stroke-width", 2)
        .attr("stroke", "#000000")
        .attr('fill', 'none');

      d3.selectAll('.barHouse')
        .append('path')
        .attr('d', 'M ' + (margin.left + bar.w / 2 + house_grid_square / 2) + ' 5' + ' l 0 ' + (house_grid_square * 2 + 5) + ' l ' + (house_grid_square * -1) + ' ' + (house_grid_square) + ' l 0 ' + (house_grid_square * 2 + 5)) //(bar.h + margin.top * 2 - 5))
        .attr("stroke-width", 2)
        .attr("stroke", "#000000")
        .attr('fill', 'none');

      // d3.select('#introPop')
      //   .append('text')
      //   .attr('class', 'majorityLabel')
      //   .text('Majority')
      //   .attr('transform', 'translate(' + (bar.w / 2 + margin.left) + ', 10)');


      // intro results

      // winner messages

      introPopWinner = introPopResultSvg
        .append('text')
        .attr('class', 'winnerTextIntro')
        .attr('x', 0)
        .attr('y', 15)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function
      
      introPresWinner = introPresResultSvg
        .append('text')
        .attr('class', 'winnerTextIntro')
        .attr('x', 0)
        .attr('y', 15)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function
      
      introHouseWinner = introHouseResultSvg
        .append('text')
        .attr('class', 'winnerTextIntro')
        .attr('x', 0)
        .attr('y', 15)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function
      
      introSenateWinner = introSenateResultSvg
        .append('text')
        .attr('class', 'winnerTextIntro')
        .attr('x', 0)
        .attr('y', 15)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function

      // result numbers

      introPopResult = introPopResultSvg
        .append('text')
        .attr('class', 'resultTextIntro')
        .attr('x', 0)
        .attr('y', 30)
        .style('fill', 'green')
        .text(''); // text gets populated by update function

      introPresResult = introPresResultSvg
        .append('text')
        .attr('class', 'resultTextIntro')
        .attr('x', 0)
        .attr('y', 30)
        .style('fill', 'green')
        .text(''); // text gets populated by update function

      introHouseResult = introHouseResultSvg
        .append('text')
        .attr('class', 'resultTextIntro')
        .attr('x', 0)
        .attr('y', 30)
        .style('fill', 'green')
        .text(''); // text gets populated by update function

      introSenateResult = introSenateResultSvg
        .append('text')
        .attr('class', 'resultTextIntro')
        .attr('x', 0)
        .attr('y', 30)
        .style('fill', 'green')
        .text(''); // text gets populated by update function

      // winner text

      presPopWinner = presPopResultSvg
        .append('text')
        .attr('class', 'winnerText')
        .attr('x', 181)
        .attr('y', 20)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function
      
      presPresWinner = presPresResultSvg
        .append('text')
        .attr('class', 'winnerText')
        .attr('x', 101)
        .attr('y', 20)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function

      housePopWinner = housePopResultSvg
        .append('text')
        .attr('class', 'winnerText')
        .attr('x', 181)
        .attr('y', 20)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function
      
      houseHouseWinner = houseHouseResultSvg
        .append('text')
        .attr('class', 'winnerText')
        .attr('x', 101)
        .attr('y', 20)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function

      senatePopWinner = senatePopResultSvg
        .append('text')
        .attr('class', 'winnerText')
        .attr('x', 181)
        .attr('y', 20)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function
      
      senateSenateWinner = senateSenateResultSvg
        .append('text')
        .attr('class', 'winnerText')
        .attr('x', 101)
        .attr('y', 20)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function


      presPopResult = presPopResultSvg
        .append('text')
        .attr('class', 'resultText')
        .attr('x', 181)
        .attr('y', 37)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function
      
      presPresResult = presPresResultSvg
        .append('text')
        .attr('class', 'resultText')
        .attr('x', 101)
        .attr('y', 37)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function

      housePopResult = housePopResultSvg
        .append('text')
        .attr('class', 'resultText')
        .attr('x', 181)
        .attr('y', 37)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function
      
      houseHouseResult = houseHouseResultSvg
        .append('text')
        .attr('class', 'resultText')
        .attr('x', 101)
        .attr('y', 37)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function

      senatePopResult = senatePopResultSvg
        .append('text')
        .attr('class', 'resultText')
        .attr('x', 181)
        .attr('y', 37)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function
      
      senateSenateResult = senateSenateResultSvg
        .append('text')
        .attr('class', 'resultText')
        .attr('x', 101)
        .attr('y', 37)
        .style('fill', 'green')
        .text('test'); // text gets populated by update function


      // UPDATE DATA

      let graphics = [];
      let results = [];

      // function for updating colors
      function update(section, vote) {

        // determine which graphics to update
        if (section == 'intro') {
          graphics = [introPopBar, introPresBar, introHouseBar, introSenateBar];
        } else if (section == 'pres') {
          graphics = [presSquares, presBar, presPop]
        } else if (section == 'house') {
          graphics = [houseSquares, houseBar, housePop]
        } else if (section == 'senate') {
          graphics = [senateSquares, senateBar, senatePop]
        };

        // update colors
        graphics.forEach(item => item.style('fill', d => {
    			return leanColor(+d.rlean + vote);
    		}));

        // calculate which party won the presidency/house/senate and how many votes/seats they won

        // R popular vote share (400 rows in popular vote data file)
        const popResultR = d3.count(
          pop_data, d => {if (+d.rlean + vote > 0) {return 1;}}) / 400;
        
        // R electoral college votes
        const presResultR = d3.sum(
          pres_data, d => {if (+d.rlean + vote > 0) {return d.electors;}});

        // R house seats
        const houseResultR = d3.count(
          house_data, d => {if (+d.rlean + vote > 0) {return 1;}});
        
        // R senate seats
        const senateResultR = d3.count(
          senate_data, d => {if (+d.rlean + vote > 0) {return 1;}});
        
        // determine winners

        let popWinner, presWinner, houseWinner, senateWinner = '';

        if (popResultR > 0.5) {
          popWinner = 'Republicans win popular vote';
        } else if (popResultR < 0.5) {
          popWinner = 'Democrats win popular vote';         
        } else if (popResultR == 0.5) {
          popWinner = 'Even popular vote';
        };

        if (presResultR > 269) {
          presWinner = 'Republicans win presidency';
        } else if (presResultR < 269) {
          presWinner = 'Democrats win presidency';         
        } else if (presResultR == 269) {
          presWinner = 'Tie (states decide)';
        };

        if (houseResultR >= 218) {
          houseWinner = 'Republicans win House';
        } else if (houseResultR < 218) {
          houseWinner = 'Democrats win House';         
        };

        if (senateResultR > 50) {
          senateWinner = 'Republicans win Senate';
        } else if (senateResultR < 50) {
          senateWinner = 'Democrats win Senate';         
        } else if (senateResultR == 50) {
          senateWinner = 'Even (vice president breaks tie)';
        };

        // determine which results to update
        // results = [introPopResult, introPopWinner, introPresResult, introHouseResult, introSenateResult];

        if (section == 'intro'){

          // update result winner messages
          introPopWinner.call(item => item.text(function(){
            return popWinner;
          }).style('fill', function(){
            if (popResultR > 0.5) {
              return red;
            } else if (popResultR < 0.5) {
              return blue;
            } else {
              return gray;
            }
          }));
          introPresWinner.call(item => item.text(function(){
            return presWinner;
          }).style('fill', function(){
            if (presResultR > 269) {
              return red;
            } else if (presResultR < 269) {
              return blue;
            } else {
              return gray;
            }
          }));
          introHouseWinner.call(item => item.text(function(){
            return houseWinner;
          }).style('fill', function(){
            if (houseResultR >= 218) {
              return red;
            } else if (houseResultR < 218) {
              return blue;
            } else {
              return gray;
            }
          }));
          introSenateWinner.call(item => item.text(function(){
            return senateWinner;
          }).style('fill', function(){
            if (senateResultR > 50) {
              return red;
            } else if (senateResultR < 50) {
              return blue;
            } else {
              return gray;
            }
          }));

          // update result numbers (which number is first depends on winner)
          introPopResult.call(item => item.text(function(){
            if (popResultR > 0.5) {
              return d3.format(".1%")(popResultR) + ' to ' + d3.format(".1%")(1 - popResultR);
            } else {
              return d3.format(".1%")(1 - popResultR) + ' to ' + d3.format(".1%")(popResultR);
            } 
          }).style('fill', function(){
            if (popResultR > 0.5) {
              return red;
            } else if (popResultR < 0.5) {
              return blue;
            } else {
              return gray;
            }
          }));
          introPresResult.call(item => item.text(function(){
            if (presResultR > 269) {
              return (presResultR) + ' EVs to ' + (538 - presResultR) + ' EVs';
            } else {
              return (538 - presResultR) + ' EVs to ' + (presResultR) + ' EVs';
            }
          }).style('fill', function(){
            if (presResultR > 269) {
              return red;
            } else if (presResultR < 269) {
              return blue;
            } else {
              return gray;
            }
          }));
          introHouseResult.call(item => item.text(function(){
            if (houseResultR >= 218) {
              return (houseResultR) + ' seats to ' + (435 - houseResultR) + ' seats';
            } else {
              return (435 - houseResultR) + ' seats to ' + (houseResultR) + ' seats';
            }
          }).style('fill', function(){
            if (houseResultR >= 218) {
              return red;
            } else if (houseResultR < 218) {
              return blue;
            } else {
              return gray;
            }
          }));
          introSenateResult.call(item => item.text(function(){
            if (senateResultR > 50) {
              return (senateResultR) + ' seats to ' + (100 - senateResultR) + ' seats';
            } else {
              return (100 - senateResultR) + ' seats to ' + (senateResultR) + ' seats';
            }
          }).style('fill', function(){
            if (senateResultR > 50) {
              return red;
            } else if (senateResultR < 50) {
              return blue;
            } else {
              return gray;
            }
          }));

        };

        if (section == 'pres'){

          // update result winner messages
          presPopWinner.call(item => item.text(function(){
            return popWinner;
          }).style('fill', function(){
            if (popResultR > 0.5) {
              return red;
            } else if (popResultR < 0.5) {
              return blue;
            } else {
              return gray;
            }
          }));
          presPresWinner.call(item => item.text(function(){
            return presWinner;
          }).style('fill', function(){
            if (presResultR > 269) {
              return red;
            } else if (presResultR < 269) {
              return blue;
            } else {
              return gray;
            }
          }));

          // update result numbers (which number is first depends on winner)
          presPopResult.call(item => item.text(function(){
            if (popResultR > 0.5) {
              return d3.format(".1%")(popResultR) + ' to ' + d3.format(".1%")(1 - popResultR);
            } else {
              return d3.format(".1%")(1 - popResultR) + ' to ' + d3.format(".1%")(popResultR);
            } 
          }).style('fill', function(){
            if (popResultR > 0.5) {
              return red;
            } else if (popResultR < 0.5) {
              return blue;
            } else {
              return gray;
            }
          }));
          presPresResult.call(item => item.text(function(){
            if (presResultR > 269) {
              return (presResultR) + ' EVs to ' + (538 - presResultR) + ' EVs';
            } else {
              return (538 - presResultR) + ' EVs to ' + (presResultR) + ' EVs';
            }
          }).style('fill', function(){
            if (presResultR > 269) {
              return red;
            } else if (presResultR < 269) {
              return blue;
            } else {
              return gray;
            }
          }));

        };

        if (section == 'house'){

          // update result winner messages
          housePopWinner.call(item => item.text(function(){
            return popWinner;
          }).style('fill', function(){
            if (popResultR > 0.5) {
              return red;
            } else if (popResultR < 0.5) {
              return blue;
            } else {
              return gray;
            }
          }));
          houseHouseWinner.call(item => item.text(function(){
            return houseWinner;
          }).style('fill', function(){
            if (houseResultR >= 218) {
              return red;
            } else if (houseResultR < 218) {
              return blue;
            } else {
              return gray;
            }
          }));

          // update result numbers (which number is first depends on winner)
          housePopResult.call(item => item.text(function(){
            if (popResultR > 0.5) {
              return d3.format(".1%")(popResultR) + ' to ' + d3.format(".1%")(1 - popResultR);
            } else {
              return d3.format(".1%")(1 - popResultR) + ' to ' + d3.format(".1%")(popResultR);
            } 
          }).style('fill', function(){
            if (popResultR > 0.5) {
              return red;
            } else if (popResultR < 0.5) {
              return blue;
            } else {
              return gray;
            }
          }));
          houseHouseResult.call(item => item.text(function(){
            if (houseResultR >= 218) {
              return (houseResultR) + ' seats to ' + (435 - houseResultR) + ' seats';
            } else {
              return (435 - houseResultR) + ' seats to ' + (houseResultR) + ' seats';
            }
          }).style('fill', function(){
            if (houseResultR >= 218) {
              return red;
            } else if (houseResultR < 218) {
              return blue;
            } else {
              return gray;
            }
          }));
        };

        if (section == 'senate'){

          // update result winner messages
          senatePopWinner.call(item => item.text(function(){
            return popWinner;
          }).style('fill', function(){
            if (popResultR > 0.5) {
              return red;
            } else if (popResultR < 0.5) {
              return blue;
            } else {
              return gray;
            }
          }));
          senateSenateWinner.call(item => item.text(function(){
            return senateWinner;
          }).style('fill', function(){
            if (senateResultR > 50) {
              return red;
            } else if (senateResultR < 50) {
              return blue;
            } else {
              return gray;
            }
          }));

          // update result numbers (which number is first depends on winner)
          senatePopResult.call(item => item.text(function(){
            if (popResultR > 0.5) {
              return d3.format(".1%")(popResultR) + ' to ' + d3.format(".1%")(1 - popResultR);
            } else {
              return d3.format(".1%")(1 - popResultR) + ' to ' + d3.format(".1%")(popResultR);
            } 
          }).style('fill', function(){
            if (popResultR > 0.5) {
              return red;
            } else if (popResultR < 0.5) {
              return blue;
            } else {
              return gray;
            }
          }));
          senateSenateResult.call(item => item.text(function(){
            if (senateResultR > 50) {
              return (senateResultR) + ' seats to ' + (100 - senateResultR) + ' seats';
            } else {
              return (100 - senateResultR) + ' seats to ' + (senateResultR) + ' seats';
            }
          }).style('fill', function(){
            if (senateResultR > 50) {
              return red;
            } else if (senateResultR < 50) {
              return blue;
            } else {
              return gray;
            }
          }));
        };





                // results.forEach(item => item.style('fill', d => {
        //   return leanColor(+d.rlean + vote);
        // }));

        // do leanColor but with gray for ties

        ////// do data calculations in the slider function and pass the output along with vote?

    	};

      // initial colors (popular vote = 0)
      update('intro', 0);
      update('pres', 0);
      update('house', 0);
      update('senate', 0);

        



      // TEST labels
      // g.append('text')
      //   .attr('x', square.w / 2)
      //   .attr('y', square.h / 2)
      //   .style('text-anchor', 'middle')
      //   .attr('transform', 'translate(0,5)')
      //   .style('fill', '#ffffff')
      //   .attr('class', 'label')
      //   .text(d=> {return d.rlean;});


      // NOTES

      // could also try using if instead of leanColor in case it gives better performance:
      // if (d.rlean >= 0) {
      //   return '#cf4938';
      // } else {
      //   return '#4287f5';
      // }

        const TESTpopResultR = d3.count(
          pop_data, d => {if (+d.rlean + 0 > 0) {return d.id;}}) / 400;
        console.log(TESTpopResultR);

        // R electoral college votes
        const TESTpresResultR = d3.sum(
          pres_data, d => {if (+d.rlean + 0 > 0) {return d.electors;}});
        console.log(TESTpresResultR);

        // R house seats
        const TESThouseResultR = d3.count(
          house_data, d => {if (+d.rlean + 0 > 0) {return d.rlean;}});
        console.log(TESThouseResultR);
        
        // R senate seats
        const TESTsenateResultR = d3.count(
          senate_data, d => {if (+d.rlean + 0 > 0) {return d.rlean;}});
        console.log(TESTsenateResultR);

    })
        .catch(function(error){
          // handle error 
          console.log(error);
    });

    </script>
  </body>
</html>